import serial
import time

SYNC = b'\x80'

# If the data frame has been received correctly and the command execution was
# successful, an acknowledge character DATA_ACK = 90h is sent back by the BSL.
DATA_ACK = b'\x90'

# Incorrectly received data frames, unsuccessful operations, and commands that
# are locked or not defined are confirmed with a DATA_NAK = A0h.
DATA_NAK = b'\xA0'

class Driver():
    # David Beazley style... https://www.youtube.com/watch?v=5nXmq1PsoJ0
    def __init__(self, device, pin, invert=False):
        self.device = device
        self.pin = pin
        self.invert = invert

    def __get__(self, instance, type=None):
        value = getattr(getattr(instance, self.device), self.pin)

        return not value if self.invert else value

    def __set__(self, instance, value):
        if self.invert:
            setattr(getattr(instance, self.device), self.pin, not value)
        else:
            setattr(getattr(instance, self.device), self.pin, value)

    def __set_name__(self, cls, name):
        self.name = name


# @TODO: Context manager? Start switch serial, do something, stop switch serial.
class ADG715():
    scl = Driver('serial', 'rts')
    sda = Driver('serial', 'dtr')

    def __init__(self, serial):
        self.serial = serial
        self.initialized = None

    def serial_start(self):
        # The master initiates data transfer by establishing a START
        # condition, which is when a high-to-low transition on the SDA line
        # occurs while SCL is high. Repeated writes are permitted without
        # requiring repeated start and stop signals.
        self.scl = True
        self.sda = True
        self.sda = False

        # Exit with signals low
        self.scl = False
        self.sda = False

        self.initialized = True

        # The digital switch is connected to the serial bus as a slave device
        # (i.e. no clock is generated by the digital switch). The following
        # byte is the address byte that consists of the 7-bit slave address
        # followed by a R/W bit. The R/W bit determines whether data will be
        # read from or written to the slave device. The serial switch as
        # configured in the TelosB has a 7-bit slave address of 1001000 (MSB
        # first). If the R/W bit is high, the master will read from the slave
        # device and if the R/W bit is low, the master will write to the slave
        # device. For the TelosB, only writing is possible as there is no way
        # to sense values (including slave acknowledgements) using RTS and DTR
        # of the serial controller. 
        self.serial_write_byte(0b10010000)

    def serial_stop(self):
        # A STOP condition is defined as a low-to-high transition on the SDA
        # line while SCL is high. Repeated writes are permitted without
        # requiring repeated start and stop signals.
        self.scl = True
        self.sda = False
        self.sda = True

        # Exit with signals low
        self.scl = False
        self.sda = False

        self.initialized = False

    def serial_write_bit(self, value):
        # The transitions on the SDA line must occur during the low period
        # of SCL and remain stable during the high period of SCL. 
        self.scl = False
        self.sda = bool(value)
        self.scl = True
        self.scl = False

    def serial_write_byte(self, value):
        # Data is transmitted over the serial bus in sequences of nine clock
        # pulses (eight data bits followed by an acknowledge bit). The
        # transitions on the SDA line must occur during the low period of SCL
        # and remain stable during the high period of SCL. Repeated writes are
        # permitted without requiring repeated start and stop signals.
        assert(value <= 0xFF)
        data = [int(bit) for bit in format(value, '08b')]
        for value in data:
            self.serial_write_bit(value)
        else:
            # The digital switch responds (acknowledges) by pulling the SDA
            # line low during the ninth clock pulse. Here 'x' is used to
            # indicate a "don't care" bit.
            self.serial_write_bit('x')

    def set_switches(self, value):
        # A repeated write function gives the user flexibility to update the
        # matrix switch a number of times after addressing the part only once.
        # During the write cycle, each data byte will update the configuration
        # of the switches. Each bit of the data byte controls one switch where
        # MSB (bit-7) is loaded first. For example, after the matrix switch
        # has acknowledged its address byte, and received one data byte, the
        # switches will update after receiving the data byte; if another data
        # byte is written to the matrix switch while it is still the addressed
        # slave device, this data byte will also cause a switch configuration
        # update.
        self.serial_write_byte(value)

        # Since TelosB cannot sense/read on serial controller RTS or DTR, keep
        # track of state of switches on write. Repeated writes are permitted
        # without requiring repeated start and stop signals.
        self.switches = value


class FT232BM(serial.Serial):
    # The TelosB implements an FT232BM serial controller.
    def __init__(self, invert_rtsdtr=False, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.invert_rtsdtr = invert_rtsdtr

    @property
    def rts(self):
        return not self._rts_state if self.invert_rtsdtr else self._rts_state

    @rts.setter
    def rts(self, value):
        self._rts_state = not value if self.invert_rtsdtr else value
        if self.is_open:
            self._update_rts_state()

    @property
    def dtr(self):
        return not self._dtr_state if self.invert_rtsdtr else self._dtr_state

    @dtr.setter
    def dtr(self, value):
        self._dtr_state = not value if self.invert_rtsdtr else value
        if self.is_open:
            self._update_dtr_state()


class TelosB():
    def __init__(self, port):
        # The UART protocol initially used by the MCU BSL is defined by fixed
        # 9600 baud in half-duplex mode (one sender at a time), 1-start bit,
        # 8-data bits (LSB first), an even parity bit, 1 stop bit. Handshake
        # is performed by an acknowledge character 0x90. Minimum time delay
        # before sending new characters after characters have been received
        # from the MSP430 BSL is 1.2 ms. Applying baud rates other than 9600
        # baud at initialization results in communication problems or violates
        # the flash memory write timing specification. The flash memory may be
        # extensively stressed or may react with unreliable program or erase
        # operations.
        self.serial = FT232BM(
            port=port,
            baudrate = 9600,
            bytesize = 8,
            parity = serial.PARITY_EVEN,
            stopbits = serial.STOPBITS_ONE,
            timeout = 5,
            write_timeout = 5,
            invert_rtsdtr=True,
            )

        self.switch = ADG715(self.serial)

        self.bsl_start()

    # @TODO: Context manager? Start switch serial, do something, stop switch serial.
    def bsl_start(self):
        # The TelosB ADG715 digital switch is controlled via an I2C compatible
        # serial bus.
        self.switch.serial_start()
        
        # The BSL program execution starts whenever the TCK pin has received a
        # minimum of two negative transitions and TCK is low while RST/NMI
        # rises from low to high (BSL entry method, see Figure 3). This level
        # transition triggering improves BSL start-up reliability.
        # 
        # The TelosB RESET (RST/NMI) is actively pulled high, setting bit-1
        # closes switch 1 and pulls the signal to low. Likewise, TCK is
        # actively pulled high, setting bit-2 closes switch 2 and pulls the
        # signal low.
        self.switch.set_switches(0b0000_0001)
        self.switch.set_switches(0b0000_0011)
        self.switch.set_switches(0b0000_0001)
        self.switch.set_switches(0b0000_0011)
        self.switch.set_switches(0b0000_0010)
        self.switch.set_switches(0b0000_0000)

        # When all data bits have been read or written, a STOP condition is
        # established by the master. 
        self.switch.serial_stop()

        # If control over the MCU UART protocol is lost, either by line faults or
        # by violating the data frame conventions, the only way to recover is
        # to rerun the BSL entry sequence to initiate another BSL session.

    def bsl_sync(self):
        """ Synchronize BSL internal parameters.

        A bsl_sync() must be performed at BSL start and before every command
        that is sent to the BSL. The synchronization character (SYNC) is 0x80.
        The SYNC provides the BSL system time reference and is used by the MCU
        to calculate internal parameters used to maintain UART and flash
        memory program and erase timings.
        
        Synx 0x80 is successfully received, an acknowledge 0x90 is sent back
        by the BSL.
        """

        self.serial.write(SYNC)

        self.serial.flushInput()
        data_acknowledge = self.serial.read()
        assert(data_acknowledge == DATA_ACK)

    def bsl_rx_data_block(self, address, data):
        """ Write data to the BSL target device.

        The receive data block command is used for any write access to the
        flash memory, RAM, or peripheral module control registers at 0000h
        to 01FFh. It is password protected.
        """

        # @TODO: Incomplete implementation
        raise NotImplementedError

        assert(length%2 != 1)
        assert(int(address) < 255)

    def bsl_rx_password(self, password=(32 * b'\xFF')):
        """ Unlock the password-protected BSL commands.

        The receive password command is used to unlock the password-protected
        commands, which perform reading, writing, or segment-erasing memory
        access. The unlock password command is not itself password protected.

        Neither start address nor block length information is necessary,
        because the 32-byte password is always located at addresses FFE0h to
        FFFFh.

        Data bytes D1 to D20h hold the password information starting with D1
        at address FFE0h.

        If the receipt and verification of the password is correct, a positive
        acknowledge DATA_ACK is sent back by the BSL, and the password-
        protected commands become unlocked. Otherwise the BSL confirms with a
        DATA_NAK.

        NOTE: Mass erase initializes the password area to 32 times 0FFh.
        """
        assert(len(password) == 32) 
        data_frame = hexstr_to_bytes('80 10 24 24 00 00 00 00') + password
        self.serial.write(append_checksum(data_frame))

        self.serial.flushInput()
        response = self.serial.read(1)
        assert(response != DATA_NAK)
        assert(response == DATA_ACK)

    def bsl_mass_erase(self):
        """ Erase the entire flash memory area.

        The mass erase command erases the entire flash memory area (main
        memory plus information memory). The mass erase command is not
        password protected. 

        After erasing, an acknowledge character DATA_ACK
        is sent back by the BSL. 

        Mass erase initializes the password area to 32 times 0FFh. 

        NOTE: BSL versions V2.01 and higher support automatic clearing of the
        LOCKA bit protecting information flash memory. When the BSL is entered
        from a reset condition, LOCKA is cleared by the BSL to mass erase the
        flash, including information memory. When the BSL is entered in-
        application, user software should ensure that LOCKA is written as 1
        prior to initiating the BSL. Otherwise, information flash is not
        erased during a BSL mass erase.
        """

        data_frame = append_checksum(hexstr_to_bytes('80 18 04 04 00 FF 06 A5'))
        self.serial.write()

        self.serial.flushInput()
        response = self.serial.read(1)
        assert(response != DATA_NAK)
        assert(response == DATA_ACK)

    def bsl_erase_segment(self):
        """ Erases specific flash memory segments.

        See section 2.4.4.5 of SLAU319 (Rev. O)
        """
        raise NotImplementedError

    def bsl_erase_main(self):
        """ Erases specific flash memory sections..

        See section 2.4.4.6 of SLAU319 (Rev. O)
        """
        raise NotImplementedError

    def bsl_erase_check(self):
        """ Verify erasure of flash memory within a certain address range.

        See section 2.4.4.7 of SLAU319 (Rev. O) 
        """
        raise NotImplementedError


    def bsl_change_baud_rate(self):
        """ Change baud rate.

        See section 2.4.4.8 of SLAU319 (Rev. O) 
        """
        raise NotImplementedError

    def bsl_set_memory_offset(self):
        """ Memory pointer for devices having more than 64KB of memory.

        See section 2.4.4.9 of SLAU319 (Rev. O) 
        """
        raise NotImplementedError

    def bsl_load_pc(self):
        """ Load program counter (register R0)

        See section 2.4.4.10 of SLAU319 (Rev. O) 
        """
        raise NotImplementedError

    def bsl_tx_data_block(self, length, address):
        """ Read access to flash memory, RAM and perpheral modules registers.

        Length and address are ints, but recall ints can be expressed like 0x0001.

        The transmit data block command is used for any read access to the
        flash memory, RAM, or peripheral module control registers at 0000h to
        01FFh. It is password protected.

        The 16-bit block start address is defined in AL (low byte) and AH
        (high byte). The 16-bit block length is defined in LL (low byte) and
        LH (high byte). Because pure data bytes are limited to a maximum of
        250, LH is always 0. The checksum bytes CKL (low byte) and CKH (high
        byte) immediately follow this information.

        Now the BSL responds with the requested data block. After transmitting
        HDR, dummy CMD, L1 and L2, The BSL sends data bytes D1 through Dn,
        followed by the checksum bytes CKL (low byte) and CKH (high byte). No
        acknowledge character is necessary.
        """
        assert(length <= 250)
        # assert(len(address) == 2)
        import struct
        data_frame = append_checksum(
            b'\x80\x14\x04\x04' + struct.pack('<HH', address, length)
            )

        self.serial.write(data_frame)

        # assert(self.serial.in_waiting == length + 6)

        return self.serial.read(length + 6)

    def bsl_tx_version(self):
        """ Read BSL version information from target.

        For MSP430F1611 as found on TelosB, expect Chip ID of 0xF16C and BSL
        version data of 0x0161 (Table 20 SLAU319 Rev. O)
        """

        data_frame = append_checksum(hexstr_to_bytes('80 1E 04 04 00 00 00 00'))
        self.serial.write(data_frame)

        self.serial.flushInput()
        response = self.serial.read(22)
        
        assert(response != DATA_NAK)
        assert(len(response) == 22)

        return response

    def test(self):
        data_frame = hexstr_to_bytes('80 14 04 04 00 0F 0E 00 75 E0')
        print(append_checksum(data_frame))
        # self.bsl_sync()
        self.serial.write(append_checksum(data_frame))

        # self.serial.flushInput()
        response = self.serial.read(16)

        print(response)




def append_checksum(data):
    """Return data with 16-bit checksum CKL, CKH append to end."""
    CKL, CKH = checksum(data)

    # print(bytes_to_hexstr(data + int(CKL).to_bytes(1, 'big') + int(CKH).to_bytes(1, 'big')))
    return data + int(CKL).to_bytes(1, 'big') + int(CKH).to_bytes(1, 'big')

def checksum(data):
    """Return the 16-bit (2-byte) checksum is calculated over all received or
    transmitted bytes B1 to Bn in the data frame, except the checksum bytes
    themselves, by XORing words (two successive bytes) and inverting the
    result.
    """
    checksum_low = ~xor(data[0::2]) & 0xFF
    checksum_high = ~xor(data[1::2]) & 0xFF
    return checksum_low, checksum_high

def xor(data):
    """Return the XOR of successive elements ."""
    xor_sum = 0
    for element in data:
        xor_sum ^= element

    # See https://docs.python.org/3/library/stdtypes.html#bytes-objects if you
    # need a friendly reminder on how byte objects behave.
    return xor_sum

def goodfet_checksum(data):
    """Calculates a checksum of "data"."""
    checksum = 0
    length = len(data)
    for i in range(length/2):
        checksum = checksum ^ ((data[i*2]) | ((data[i*2+1]) << 8))    #xor-ing
    return 0xffff & (checksum ^ 0xffff)         #inverting

def hexstr_to_bytes(value):
    """Return bytes object and filter out formatting characters from a string of hexadecimal numbers."""
    return bytes.fromhex(''.join(filter(str.isalnum, value)))

def bytes_to_hexstr(value, start='', sep=' '):
    """Return string of hexadecimal numbers separated by spaces from a bytes object."""
    return start + sep.join(["{:02X}".format(byte) for byte in bytes(value)])

def int_to_bytes(value, length=1, signed=False):
    """Return bytes given integer"""
    return int(value).to_bytes(length, byteorder='big', signed=signed)

if __name__ == '__main__':
    telos = TelosB('/dev/ttyUSB0')