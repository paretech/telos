import serial
import time

class Driver():
    # David Beazley style... https://www.youtube.com/watch?v=5nXmq1PsoJ0
    def __init__(self, device, pin, invert=False):
        self.device = device
        self.pin = pin
        self.invert = invert

    def __get__(self, instance, type=None):
        value = getattr(getattr(instance, self.device), self.pin)

        return not value if self.invert else value

    def __set__(self, instance, value):
        if self.invert:
            setattr(getattr(instance, self.device), self.pin, not value)
        else:
            setattr(getattr(instance, self.device), self.pin, value)

    def __set_name__(self, cls, name):
        self.name = name


class ADG715():
    scl = Driver('serial', 'rts')
    sda = Driver('serial', 'dtr')

    def __init__(self, serial):
        self.serial = serial
        self.initialized = None

    def serial_start(self):
        # The master initiates data transfer by establishing a START
        # condition, which is when a high-to-low transition on the SDA line
        # occurs while SCL is high. Repeated writes are permitted without
        # requiring repeated start and stop signals.
        self.scl = True
        self.sda = True
        self.sda = False

        # Exit with signals low
        self.scl = False
        self.sda = False

        self.initialized = True

        # The digital switch is connected to the serial bus as a slave device
        # (i.e. no clock is generated by the digital switch). The following
        # byte is the address byte that consists of the 7-bit slave address
        # followed by a R/W bit. The R/W bit determines whether data will be
        # read from or written to the slave device. The serial switch as
        # configured in the TelosB has a 7-bit slave address of 1001000 (MSB
        # first). If the R/W bit is high, the master will read from the slave
        # device and if the R/W bit is low, the master will write to the slave
        # device. For the TelosB, only writing is possible as there is no way
        # to sense values (including slave acknowledgements) using RTS and DTR
        # of the serial controller. 
        self.serial_write_byte(0b10010000)

    def serial_stop(self):
        # A STOP condition is defined as a low-to-high transition on the SDA
        # line while SCL is high. Repeated writes are permitted without
        # requiring repeated start and stop signals.
        self.scl = True
        self.sda = False
        self.sda = True

        # Exit with signals low
        self.scl = False
        self.sda = False

        self.initialized = False

    def serial_write_bit(self, value):
        # The transitions on the SDA line must occur during the low period
        # of SCL and remain stable during the high period of SCL. 
        self.scl = False
        self.sda = bool(value)
        self.scl = True
        self.scl = False

    def serial_write_byte(self, value):
        # Data is transmitted over the serial bus in sequences of nine clock
        # pulses (eight data bits followed by an acknowledge bit). The
        # transitions on the SDA line must occur during the low period of SCL
        # and remain stable during the high period of SCL. Repeated writes are
        # permitted without requiring repeated start and stop signals.
        assert(value <= 0xFF)
        data = [int(bit) for bit in format(value, '08b')]
        for value in data:
            self.serial_write_bit(value)
        else:
            # The digital switch responds (acknowledges) by pulling the SDA
            # line low during the ninth clock pulse. Here 'x' is used to
            # indicate a "don't care" bit.
            self.serial_write_bit('x')

    def set_switches(self, value):
        # A repeated write function gives the user flexibility to update the
        # matrix switch a number of times after addressing the part only once.
        # During the write cycle, each data byte will update the configuration
        # of the switches. Each bit of the data byte controls one switch where
        # MSB (bit-7) is loaded first. For example, after the matrix switch
        # has acknowledged its address byte, and received one data byte, the
        # switches will update after receiving the data byte; if another data
        # byte is written to the matrix switch while it is still the addressed
        # slave device, this data byte will also cause a switch configuration
        # update.
        self.serial_write_byte(value)

        # Since TelosB cannot sense/read on serial controller RTS or DTR, keep
        # track of state of switches on write. Repeated writes are permitted
        # without requiring repeated start and stop signals.
        self.switches = value


class FT232BM(serial.Serial):
    # The TelosB implements an FT232BM serial controller.
    def __init__(self, invert_rtsdtr=False, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.invert_rtsdtr = invert_rtsdtr

    @property
    def rts(self):
        return not self._rts_state if self.invert_rtsdtr else self._rts_state

    @rts.setter
    def rts(self, value):
        self._rts_state = not value if self.invert_rtsdtr else value
        if self.is_open:
            self._update_rts_state()

    @property
    def dtr(self):
        return not self._dtr_state if self.invert_rtsdtr else self._dtr_state

    @dtr.setter
    def dtr(self, value):
        self._dtr_state = not value if self.invert_rtsdtr else value
        if self.is_open:
            self._update_dtr_state()


class TelosB():
    def __init__(self, port):
        # The UART protocol initially used by the MCU BSL is defined by fixed
        # 9600 baud in half-duplex mode (one sender at a time), 1-start bit,
        # 8-data bits (LSB first), an even parity bit, 1 stop bit. Handshake
        # is performed by an acknowledge character 0x90. Minimum time delay
        # before sending new characters after characters have been received
        # from the MSP430 BSL is 1.2 ms. Applying baud rates other than 9600
        # baud at initialization results in communication problems or violates
        # the flash memory write timing specification. The flash memory may be
        # extensively stressed or may react with unreliable program or erase
        # operations.
        self.serial = FT232BM(
            port=port,
            baudrate = 9600,
            bytesize = 8,
            parity = serial.PARITY_EVEN,
            stopbits = serial.STOPBITS_ONE,
            timeout = 5,
            write_timeout = 5,
            invert_rtsdtr=True,
            )

        self.switch = ADG715(self.serial)

        self.bsl_start()
        self.bsl_sync()


    def bsl_start(self):
        # The TelosB ADG715 digital switch is controlled via an I2C compatible
        # serial bus.
        self.switch.serial_start()
        
        # The BSL program execution starts whenever the TCK pin has received a
        # minimum of two negative transitions and TCK is low while RST/NMI
        # rises from low to high (BSL entry method, see Figure 3). This level
        # transition triggering improves BSL start-up reliability.
        # 
        # The TelosB RESET (RST/NMI) is actively pulled high, setting bit-1
        # closes switch 1 and pulls the signal to low. Likewise, TCK is
        # actively pulled high, setting bit-2 closes switch 2 and pulls the
        # signal low.
        self.switch.set_switches(0b0000_0001)
        self.switch.set_switches(0b0000_0011)
        self.switch.set_switches(0b0000_0001)
        self.switch.set_switches(0b0000_0011)
        self.switch.set_switches(0b0000_0010)
        self.switch.set_switches(0b0000_0000)

        # When all data bits have been read or written, a STOP condition is
        # established by the master. 
        self.switch.serial_stop()

    def bsl_sync(self):
        # Before sending any command to the MCU's BSL, a synchronization character
        # (SYNC) with its value of 0x80 must be sent to the BSL. This character
        # is necessary to calculate all the essential internal parameters,
        # which maintain UART and flash memory program and erase timings. It
        # provides the BSL system time reference. When this is received, an
        # acknowledge 0x90 is sent back by the BSL to confirm
        # successful reception. A bsl_sync() must be performed before every
        # command that is sent to the BSL.
        self.serial.write(b'\x80')
        self.serial.flushInput()
        data_acknowledge = self.serial.read()

        assert(data_acknowledge == b'\x90')


if __name__ == '__main__':
    telos = TelosB('/dev/ttyUSB0')
