*********************************
So I have 400 TelosB's, Now What?
*********************************

So you remember Travis Goodspeed right? Well, I have about 400 MSP430 boards called TelosB that should be in his hands... Hamvention 2017...

http://goodfet.sourceforge.net/hardware/telosb/

Install binutils-msp4340, gcc-msp430, msp430-libc, and msp430mcu from AUR (abdullatif).

..code-block:: sh

    pacman -S mspgcc
    pacman -S binutils-msp430
    pacman -U binutils-msp430-2.21.1a-1-x86_64.pkg.tar.xz
    pacman -U gcc-msp430-4.6.3-1-x86_64.pkg.tar.xz
    pacman -U msp430-libc-20120224-1-x86_64.pkg.tar.xz
    pacman -U msp430mcu-20120406-1-any.pkg.tar.xz

    clone git@github.com:travisgoodspeed/goodfet.git

    cd goodfet/firmware
    export board=telosb
    make clean all

    ../client/goodfet.bsl --telosb -c /dev/ttyUSB0 -r -e -I -p goodfet.hex

If all went well well there should now be a `goodfet.hex` file. Bad news is the goodfet bootstrap loader (BSL) responds with BSL Exception "NAK received (wrong password?)". For now that's okay as our good friend @rho in Texas let us know that the RIOT-OS bootloader appears to work just fine.

..code-block:: sh

    git clone git@github.com:RIOT-OS/RIOT.git

    ./RIOT/dist/tools/goodfet/goodfet.bsl --telosb -c /dev/ttyUSB0 -r -e -I -p goodfet/firmware/goodfet.hex
    MSP430 Bootstrap Loader Version: 1.39-goodfet-8
    Mass Erase...
    Transmit default password ...
    Invoking BSL...
    Transmit default password ...
    Current bootstrap loader version: 1.61 (Device ID: f16c)
    Changing baudrate to 38400 ...
    Program ...
    9170 bytes programmed.
    Reset device ...

Sweet!

..code-block:: sh

    # pacman -S python2-virtualenve

    $ cd goodfet
    $ virtualenv2 venv
    $ source venv/bin/activate
    $ pip install pyserial

    $ usermod -a -G uucp $username

    $ /dev/ttyUSB0
    Found   CC2420
    Freq:   2405.000000 MHz
    Status:
    (venv) [paretech@osprey goodfet]$ ./client/goodfet.spiflash info
    Ident as MISSING M25P80
    Manufacturer: ff MISSING
    Type: ff
    Capacity: ff (1048576 bytes)

    $ ./client/goodfet.ccspi info
    ON: /dev/ttyUSB0
    Found   CC2420
    Freq:   2405.000000 MHz
    Status:

So what does this all mean? Well there is work to be done on the BSL loader that comes with goodfet but that from RIOT is immediately useful. Also, the goodfet firmware was successfully built, the goodfet client executes and is able to query the telosb hardware. Note too shabby for a few minutes of work! Some notes were even made in the process! Good job...

It's kind of interesting, the goodfet, TinyOS, and RIOT-OS all appear to be using some variation of the same BSL. They all look like really terrible python... However, the BSL from both TinyOS and RIOT-OS appear to work!

If get error "stdint.h" no such file or directory. Then problem may be that msp430-libc was not installed.

Porting to Python 3
===================

The `StingIO` and `cStringIO` modules are gone (in python 3). Instead, import the `io` module and use `io.StringIO` or `io.BytesIO` for text and data respectively.

Programming the Telos
=====================

The Telos (Rev. B) microcontroller (MSP430F1611) can be programmed using the
Bootstrap Loader (BSL) via the onboard USB controller (FT232BM). Between the
USB controller and the microcontroller there is a 2-Wire I2C compatable
digital switch (ADG715). The switch is used to prevent unwanted conventional
serial port signals (RTS and DTR?) from unintentionally reaching the
microcontroller. The 2-Wire I2C compatable protocol is implemented (bit-
banged) by Telos bsl.py over the RTS and DTR lines of the USB controller. Sending an appropriate series of signals, the USB controller can then be used to command the serial switch which can then be used to execute the microcontroller BSL entry sequence. After a successful entry sequence, the digital switch is no longer needed as the USB controller can communicate directly with the microcontroller using the data frame protocol called serial standard protocol (SSP) (see TI-SLAU319 for additional details). 

The digital switch is controlled via an I2C-compatible *2-wire serial bus* protocol. The digital switch is connected to the 2-wire serial bus as a slave device (i.e. no clock is generated by the digital switch). The digital switch has a 7-bit 2-wire slave address of b'1001000'

The 2-wire serial bus protocol operates as follows:

1.  The master initiates data transfer by establishing a START condition, which is when a high-to-low transition on the SDA line occurs while SCL is high. The following byte is the address byte that consists of the 7-bit slave address followed by a R/ W bit (this bit determines whether data will be read from or written to the slave device).

The slave whose address corresponds to the transmitted address responds by pulling the SDA line low during the ninth c lock pulse (this is termed the acknowledge bit). At this stage, all other devices on the bus remain idle while the selected device waits for data to be written to or read from its serial register. If the R/ W bit is high, the master will read from the slave device. However, if the R/ W bit is low, the master will write to the slave device.

2.  Data is transmitted over the serial bus in sequences of nine clock pulses (eight data bits followed by an acknowledge bit). The transitions on the SDA line must occur during the low period of SCL and remain stable during the high period of SCL.

3.  When all data bits have been read or writt en, a STOP con- dition is established by the master. A STOP condition is defined as a low-to-high transition on the SDA line while SCL is high. In write mode, the master will pull the SDA line high during the tenth clock pulse to establish a STOP condition. In read mode, the master will issue a no acknowledge for the ninth clock pulse (i.e., the SDA line remains high). The master will then bring the SDA line low before the tenth clock pulse and then high during the tenth clock pulse to estab-lish a STOP condition.

Highlights of the BSL Commands
==============================

The SYNC
--------
Every BSL command must be proceeded by a SYNC. In bsl.py the SYNC is called by decorating BSL command methods.

Passwords
---------
With the exception of a few BSL commands, most commands, including the password command itself, are password protected. If the password is not known and the device firmware is not intended for recovery, simply perform a mass erase and use the "default" password `32*b'\xFF\xFF'`.

The 32-byte password is always located at addresses FFE0h to FFFFh. If you are already authenticated with the device, the password can be found be executing `telos.bsl_tx_data_block(32, 0xffe0)[4:-2]`. 

If you have the ELF file the interrupt vector can be found by dissassembly `msp430-objdump -D $if` and inspecting for `__ivtbl_16`. 

The password can also be easily read directly from the Intel hex file. Find the 32-byte data record 0xFFE0-0xFFFF. For example, if using the Python IntexHex library, `ihex.tobinstr(start=0xffe0, size=32)`.

For example, a goodfet firmware recently built and loaded had password `telos.bsl_rx_password(15*b'\x22\x41' + b'\x00\x40')`.


Interrupt Vector
----------------

The interrupt vectors and the power-up starting address are located in the address range 0FFFFh to 0FFE0h. The vector contains the 16-bit address of the appropriate interrupt-handler instruction sequence.


Toolchain
=========

Previously been using AUR packages for https://sourceforge.net/projects/mspgcc/. This project indicates that it is obsolete and links visitors to  http://www.ti.com/tool/msp430-gcc-opensource.

TI now reports that this package may be unmaintained.

AUR packages point to https://aur.archlinux.org/packages/mspgcc-ti/ for latest TI post at http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSPGCC/latest/index_FDS.html. Need to enable multilib to use this package due to lib32 dependencies. https://wiki.archlinux.org/index.php/multilib

Updating MSP GCC is left as a future activity as the packages provided by ABDULLATIF are at least working well enough to compile goodfet and some simple examples.



Building Examples
=================

Blink
-----

..code-block:: sh

    $ msp430-gcc -mmcu=msp430f1611 -o blink.elf blink.c
    $ msp430-objcopy -O ihex blink.elf blink.hex

Third Party Examples and Tutorials
----------------------------------

#. http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials
#. http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_LED_Timer
#. 

SLAU131Q
========
- 3.1.1 Load and Run Addresses
- 3.1.2 Bootstrap Loading
- 3.2 Entry Point
- 3.3.1
  

SLAU132Q
========
- 4.3.3 Initialization by the Interrupt Vector
  
If you are using an interrupt vector, the entry point is installed as the RESET interrupt handler. When RESET is applied, the startup routine will be invoked. 
// MSP reboot count for reset input & reboot function located at 0xFFFE

References
==========

#. http://www2.ece.ohio-state.edu/~bibyk/ee582/telosMote.pdf
#. https://github.com/travisgoodspeed/goodfet
#. http://goodfet.sourceforge.net/hardware/telosb/
#. https://github.com/RIOT-OS/RIOT
#. https://riot-os.org/
#. https://github.com/tinyos/tinyos-main
#. http://tinyos.net/
#. http://travisgoodspeed.blogspot.com/2011/03/goodfet-on-telosb-tmote-sky.html
#. http://www.pages.drexel.edu/~kws23/tutorials/motes/motes.html
